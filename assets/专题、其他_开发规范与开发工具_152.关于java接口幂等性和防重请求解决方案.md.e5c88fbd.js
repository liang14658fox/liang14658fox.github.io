import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.681fc4ae.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"专题、其他/开发规范与开发工具/152.关于java接口幂等性和防重请求解决方案.md","filePath":"专题、其他/开发规范与开发工具/152.关于java接口幂等性和防重请求解决方案.md","lastUpdated":1719474694000}'),e={name:"专题、其他/开发规范与开发工具/152.关于java接口幂等性和防重请求解决方案.md"},p=l(`<h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>接口幂等性是指对同一操作的一次请求或多次请求返回的结果是一致的，不会因为多次请求就产生不一样的结果，比如数据库的select操作，可以看成是幂等性的，而插入和更新操作，则要保证重复提交造成的数据重复或者数据不正确的问题。</p><p>比如新增操作，假设名称不能重复，那么往往就要保证在新增过程中使数据库不要出现同名的数据，这是典型的防重操作。</p><p>比如更新操作，假设每次更新数值加一，那么就要保证在新增过程中不会因为重复请求而导致数值增加错乱，要保证幂等性，如果只是update 表 set is_enable = 0或1这种固定的值，就没关系，这种操作是幂等性的。</p><p>防重，顾名思义，防止数据库产生重复数据，对返回的结果是没什么要求的，所以如果是幂等性处理，在数据防重的基础上，还要把重复提交的请求返回的结果和第一次提交的请求返回的结果保持一致，比如统一返回操作成功的提示，但只有第一次是真正执行了。</p><p>##适用场景</p><ol><li>前端如果忘了做遮罩层，快速点击多次新增的情况下，数据库极易出现重复数据；</li><li>微服务间调用接口超时的时候，如果配置了重试机制，也很容易出现重复请求的情况；</li><li>在使用rocketMq消息队列在消费消息的时候，有时也会同时有重复消费的情况，比如下面两种情况：</li></ol><ul><li>① 消息生产者没有收到消息队列收到消息的应答，重试机制使得重复产生消息。 比如网络故障导致应答消息丢失或者消息太多 ，应答消息传回受到阻塞，生产者等待超时。</li><li>② 消息已经到达消息队列，但发送给消费者的时候，没有收到来自消费者的回复消息，或者消息中间件更改消息状态出现问题。</li></ul><h2 id="常用的解决方案" tabindex="-1">常用的解决方案 <a class="header-anchor" href="#常用的解决方案" aria-label="Permalink to &quot;常用的解决方案&quot;">​</a></h2><p>数据新增的时候通常先从数据库select确认数据不存在后再插入，但是这样依然无法避免多次连击的情况（实测，只要够快），所以思路大体分成两个方向，一个是用数据库方式解决，一个是非数据库的方式。</p><p>数据库方向可分为：悲观锁、乐观锁、加唯一索引、建防重表（本质上还是唯一索引），加状态字段，更新完改变状态（本质上和乐观锁很像）</p><p>非数据库方向可分为：借用第三方缓存解决，比如redis或者结合前端用token.</p><p>先说一下我觉得这里面最适合的方式，用数据库解决会加重数据库的性能负担，而token的方案，要请求两次，而且要前端配合（既然都要前端配合了，不如直接让前端加个遮罩层来的快速方便）所以优先考虑用redis做分布式锁的方式，下面也会稍微介绍下每个方式的原理。</p><h2 id="redis分布式锁" tabindex="-1">redis分布式锁 <a class="header-anchor" href="#redis分布式锁" aria-label="Permalink to &quot;redis分布式锁&quot;">​</a></h2><p>比如新增用户的接口，请求开始时，先把不能重复的字段比如用户名放到redis缓存里，可以用set或者setnx都行，设置比如两秒的过期时间（可根据业务自行设置），然后再select数据库里有没这个用户，如果没有则插入，插入成功之后删除redis里的缓存，返回操作成功。此时，如果有其他重复的请求进来，redis里已经有缓存的情况下，则直接返回操作成功就好了，或者返回数据已存在的提示，但是不会再往下执行。</p><p>这种方法应该是最简单的，而且效率最高的方法了。原理和数据库的分布式锁差不多，只是放在了redis里不会影响数据库的性能。但是关键最后一定要删除redis里的缓存。</p><h2 id="token方案" tabindex="-1">token方案 <a class="header-anchor" href="#token方案" aria-label="Permalink to &quot;token方案&quot;">​</a></h2><p>需要让前端先请求后台生成token的接口，然后前端请求的时候header里带上这个token,后台拿到token之后放入redis里，设置缓存过期时间，再去数据库select看数据存不存在，不存在则新增，成功之后删除redis里的token,这种方案，要求前端那边请求两次，一次拿token，一次业务请求带上token,而且快速点击时，多次请求带的都是同一个token, 这个原理上还是分布式锁，只是可以全局配置，并不关心具体是什么字段，但是要请求方在请求之前先拿到唯一的token,如果连拿token这个请求都是重复的话就不太容易判断了。</p><h2 id="数据库悲观锁" tabindex="-1">数据库悲观锁 <a class="header-anchor" href="#数据库悲观锁" aria-label="Permalink to &quot;数据库悲观锁&quot;">​</a></h2><p>利用select for update锁住数据库中的一行数据，更新完之后别的请求才能更新这条数据,比如：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#4D9375;">select</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">*</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">from</span><span style="color:#DBD7CAEE;"> user </span><span style="color:#4D9375;">where</span><span style="color:#DBD7CAEE;"> id</span><span style="color:#CB7676;">=</span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">for</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">update</span><span style="color:#DBD7CAEE;">;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#1E754F;">select</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">*</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">from</span><span style="color:#393A34;"> user </span><span style="color:#1E754F;">where</span><span style="color:#393A34;"> id</span><span style="color:#AB5959;">=</span><span style="color:#2F798A;">1</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">for</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">update</span><span style="color:#393A34;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样再更新这一行的数值做加减运算的时候就不怕用其他并发请求过来引发数据错乱问题了,比如：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#4D9375;">update</span><span style="color:#DBD7CAEE;"> user </span><span style="color:#4D9375;">set</span><span style="color:#DBD7CAEE;"> like_num </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> like_num</span><span style="color:#CB7676;">+</span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">where</span><span style="color:#DBD7CAEE;"> id </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;">;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#1E754F;">update</span><span style="color:#393A34;"> user </span><span style="color:#1E754F;">set</span><span style="color:#393A34;"> like_num </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> like_num</span><span style="color:#AB5959;">+</span><span style="color:#2F798A;">1</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">where</span><span style="color:#393A34;"> id </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">1</span><span style="color:#393A34;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>但是这种需要注意，如果是mysql，存储引擎必须用支持事物的innodb，这里id字段一定要是主键或者唯一索引，不然会锁住整张表。</p><h2 id="数据库乐观锁" tabindex="-1">数据库乐观锁 <a class="header-anchor" href="#数据库乐观锁" aria-label="Permalink to &quot;数据库乐观锁&quot;">​</a></h2><p>给要操作的行加个版本字段，每次更新前先查出这一行数据的版本，更新的时候指定这一行数据和版本，并且版本id+1，比如：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#4D9375;">update</span><span style="color:#DBD7CAEE;"> user </span><span style="color:#4D9375;">set</span><span style="color:#DBD7CAEE;"> like_num </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> like_num</span><span style="color:#CB7676;">+</span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;">,</span><span style="color:#4D9375;">version</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">version</span><span style="color:#CB7676;">+</span><span style="color:#4C9A91;">1</span></span>
<span class="line"><span style="color:#4D9375;">where</span><span style="color:#DBD7CAEE;"> id </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">and</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">version</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;">;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#1E754F;">update</span><span style="color:#393A34;"> user </span><span style="color:#1E754F;">set</span><span style="color:#393A34;"> like_num </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> like_num</span><span style="color:#AB5959;">+</span><span style="color:#2F798A;">1</span><span style="color:#393A34;">,</span><span style="color:#1E754F;">version</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">version</span><span style="color:#AB5959;">+</span><span style="color:#2F798A;">1</span></span>
<span class="line"><span style="color:#1E754F;">where</span><span style="color:#393A34;"> id </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">1</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">and</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">version</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">1</span><span style="color:#393A34;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样即便有重复请求，但是更新之后version变成了2，那么再更新version=1的必然不会生效。</p><p>以上两种数据库操作并不会解决新增数据重复的问题，能解决更新数据数值计算错乱的问题。</p><h2 id="加唯一索引" tabindex="-1">加唯一索引 <a class="header-anchor" href="#加唯一索引" aria-label="Permalink to &quot;加唯一索引&quot;">​</a></h2><p>这个基本是数据库版的分布式锁，有效解决数据重复问题，当插入重复字段数据时，会抛异常，不会插入成功。</p><h2 id="建防重表" tabindex="-1">建防重表 <a class="header-anchor" href="#建防重表" aria-label="Permalink to &quot;建防重表&quot;">​</a></h2><p>这种是把上面的唯一索引单独建一张表，这样就能在需要防重的时候先插入防重表来防重，不需要防重的时候又能存储这个字段的重复数据，更加灵活一点，这个思路把这个防重表放到redis里就是redis分布式锁了，其实思路差不多，只是一个在数据库，一个借助第三方缓存。</p><h2 id="加状态字段" tabindex="-1">加状态字段 <a class="header-anchor" href="#加状态字段" aria-label="Permalink to &quot;加状态字段&quot;">​</a></h2><p>比如活动待审核-审核中-已审核-执行-结束-删除等流程操作的时候，每次更新都会造成状态的改变，这个就像是上面加了版本字段一个原理，更新的时候指定状态，更新完之后状态也改变了，这样重复的请求过来就不会更新成功,比如：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#4D9375;">update</span><span style="color:#DBD7CAEE;"> activity </span><span style="color:#4D9375;">set</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">status</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">2</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">where</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">status</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4D9375;">and</span><span style="color:#DBD7CAEE;"> id </span><span style="color:#CB7676;">=</span><span style="color:#DBD7CAEE;"> </span><span style="color:#4C9A91;">1</span><span style="color:#DBD7CAEE;">;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#1E754F;">update</span><span style="color:#393A34;"> activity </span><span style="color:#1E754F;">set</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">status</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">2</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">where</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">status</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">1</span><span style="color:#393A34;"> </span><span style="color:#1E754F;">and</span><span style="color:#393A34;"> id </span><span style="color:#AB5959;">=</span><span style="color:#393A34;"> </span><span style="color:#2F798A;">1</span><span style="color:#393A34;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>综上，感觉redis缓存分布式锁的方式是效率最高的，推荐这个。 不同业务需求可以结合使用，会更香。</p><p>比如转账场景，先把订单id放入redis缓存做分布式锁，然后用数据库乐观锁加个版本字段控制，会更加保险一点。</p>`,39),o=[p];function t(r,c,i,y,d,A){return a(),n("div",null,o)}const h=s(e,[["render",t]]);export{E as __pageData,h as default};
